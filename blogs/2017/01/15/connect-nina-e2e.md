---
Order: 23
TOCTitle: Node.js Development with Visual Studio Code and Azure
PageTitle: Node.js Development with Visual Studio Code and Azure
MetaDescription: Node.js Development with Visual Studio Code and Azure
Date: 2017-01-15
ShortDescription: Node.js Development with Visual Studio Code and Azure
Author: Jonathan Carter
---

# Node.js Visual Studio Code と Azure を使用した開発

20017年1月4日 - Jonathan Carter、[@lostintangent](https://twitter.com/LostInTangent)

Visual Studio CodeとAzureの間で、Node.jsアプリケーションのビルド、デバッグ、およびデプロイの開発者の経験を簡素化し、改善することに貢献しています。 [Node Interactive North America 2016](events.linuxfoundation.org/events/node-interactive)で、私はコミュニティのフィードバックに基づいて最近行ってきた作業の一部をデモできるようになったので、この記事ではそれを試したい人や、私が話していたよりも少し詳細を探している人のためのワークフローを捉えてください。

このデモでは、[Scotch.io](https://scotch.io/tutorials/creating-a-single-page-todo-app-with-node-and-angular)によって作成され、発行された簡単なTodoアプリケーションを使用しています。 。これは単一ページのMEANアプリケーションであるため、データベースとしてMongoDB、REST API/Webサーバー用にNode/Express、フロントエンドUIにAngular.js 1.xを使用します。次のToCを使用して特定の関心のあるセクションにジャンプし、そうでない場合は先読みを続けます。

* [前提条件](＃前提条件)
* [プロジェクト設定](＃project-setup)
* [統合端末](＃統合端末)
* [統合Gitバージョン管理](＃統合Gitバージョン管理)
* [プロジェクト/コードナビゲーション](＃project - code-navigation)
* [オートコンプリート](＃オートコンプリート)
* [アプリケーションを実行する](＃running-the-app)
* [統合デバッグ](＃デバッグ)
* [フルスタックデバッグ](＃フルスタックデバッグ)
* [あなたのアプリケーションをドッキングする](あなたのアプリケーションをドッキングする)
* [あなたのアプリケーションの配備](＃deploying-your-app)
* [DocumentDBを使う](＃using-documentdb)
* [クリーンアップ](＃クリーンアップ)
* [結論](＃結論)

## 前提条件

このデモを効果的に実行するには、次のソフトウェアをインストールする必要があります。

1. Visual Studioのコードインサイダービルド。ここからダウンロードできます(https://code.visualstudio.com/insiders)。あなたは技術的にインサイダービルドは必要ありませんが、最新のバグフィックス/機能拡張(Chrome Canaryビルドと同じように)にアクセスできるので、誰でも使用してください。また、 VS Code チームが使用するのと同じビルドです。

2.ドッカーは、[こちら](https://www.docker.com/products/docker)からダウンロードできます。さらに、ウォークスルーで作成されるDockerイメージを公開するには、[DockerHub](https://hub.docker.com/)アカウントが必要です。

Azure CLI(> = `v0.1.0b11`)は、インストール手順[here](https://github.com/Azure/azure-cli#interactive-install-script)を提供します。さらに、Azureアカウントが必要で、Azure CLIを使用してログインするには、 `az login`を実行し、対話型ログインに従います。

4.糸、ここにインストール手順[ここ](https://yarnpkg.com/en/docs/install)を提供します。これは技術的には必須ではありませんが、以下のNPMクライアントの代わりに使用されます。私はそれをお勧めしたい！

さらに、デモアプリケーションはMongoDBを使用しているので、標準的な `27017`ポートでリッスンしているMongoDBインスタンスをローカルに実行する必要があります。これを実現する最も簡単な方法は、Dockerをインストールした後に次のコマンドを実行することです。 `docker run -it -p 27017：27017 mongo`。

##プロジェクト設定

開始するには、Todoサンプルプロジェクトを取得して、それを使い始める必要があります。これを行うには、次の手順を実行します。

1. Visual Studio Codeを開き、 `F1`を入力して** Command Palette **を表示させます(または、` View`メニューから `Command Palette ...`を選択します)。

2. `git：Clone`コマンドを見つけて` ENTER`を打つために `gitcl`と打ちます。

<img src = "/images/2017_01_03_GitClone.png" width = "250px" />

>注： VS Code **コマンドパレット**は「ファジィ検索」をサポートしており、一般的に使用されているコマンドを見つけるためのキーストロークを少なく入力できます。

3.プロンプトに `https：//github.com/scotch-io/node-todo`と入力し、` ENTER`を押します。

4.プロジェクトをクローンするフォルダを選択するか、新しいプロジェクトを作成します(例えば、 `Todos`と呼ばれます)。この時点で、 VS Code はリポジトリをクローンし、新しくクローンされたプロジェクトに根ざした新しいワークスペースを起動します。

<img src = "/images/2017_01_03_Explorer.png" width = "150px" />

また、Git CLIを使用してサンプルレポをクローンすることもできますが、この演習では、 VS Code がコマンドパレットを使用して提供する生産性エンハンサーの一部を説明しています。私はあなたが他に何ができるのかを特定するために、 `F1`を押して、それがインストールされている様々なコマンドをブラウズすることをお勧めします。

##一体型ターミナル

これはNode.jsプロジェクトなので、まずGitリポジトリにチェックインされていないため、すべての依存関係がNPMからインストールされていることを確認する必要があります。この手順は標準の端末から実行することができます(私は[Hyper](https://hyper.is/)をお勧めします)！また、好きな場合は、 CTRL + `` `を実行してから、好きなNPMクライアントに応じて` npm install`または `yarn`を実行します。私は糸がとても好きですし、ワークフローもすばらしく改良されているので、糸が好きです。

<img src = "/images/2017_01_03_Terminal.png" width = "400px" />

 VS Code は既存のワークフローに自然に適合したいので、統合端末が有用かどうかはいつでも決まります。  VS Code をフルスクリーンで実行している場合(特に新しいZenモードの場合)、シンプル/ワンオフコマンドに統合端末を使用できることがうれしいです。私がもっと洗練されたものをやっているのであれば、フルスクリーン版のHyperに切り替えるだけです。選択と柔軟性はここで重要です。

##統合Gitバージョン管理

ヤーンを介してアプリの依存関係をインストールすると、 `yarn.lock`ファイルが生成されました.CDビルド、プロダクションデプロイメント、または他の開発者のマシンで驚くことなく、将来的に正確に同じ依存関係を再取得する予測可能な方法を提供します。

このファイルをソースコントロールにチェックインすることをお勧めします。これを行うには、 VS Code (Gitロゴ付き)の統合Gitタブに簡単に切り替えて、新しく追加されたファイルに気付くことができます。コミットメッセージを入力し、ローカルで変更をステージング/コミットするために `CMD + Enter`(またはチェックマークアイコンをクリック)をタイプすることができます。

<img src = "/images/2017_01_03_Git.png" width = "250px" />

その背後では、手動で実行した同じGit CLIコマンドを自動化するだけなので、 VS Code の統合があなたのために機能するかどうかを決定することができます。好奇心が強いなら、 `...`メニュー項目をクリックし、 `Show Git Output`を選択することでGit出力ウィンドウを表示することができます。これは、あなたのために VS Code が実行している基本的なGitアクティビティをすべて表示します。

<img src = "/images/2017_01_03_GitOutput.png" width = "300px" />

##プロジェクト/コードナビゲーション

コードベースの中に自分自身を向けるために、 VS Code が提供するいくつかのナビゲーション機能のいくつかの例を試してみましょう：

1. `CMD + P`と打ち込んで` .js`と入力します。これにより、プロジェクト内のすべてのJavaScript/JSONファイルとその中のディレクトリを見ることができます。もう一度、このダイアログはコマンドパレットと同じ "ファジィ検索"をサポートしているので、非常に柔軟です。

    <img src = "/images/2017_01_03_FilePicker.png" width = "300px" /> <br />

2.アプリケーションの起動スクリプトである `server.js`を選択します。

3. 6行目にインポートされた `database`変数にカーソルを置いて、その変数が" type "であることを確認します。ファイル内の変数/モジュール/タイプをすばやく調べるこの機能は、特にコードを書くよりもコードを読む/理解する時間が長くなる傾向があるため、非常に便利です。

    <img src = "/images/2017_01_03_HoverHelp.png" width = "200px" /> <br />

4.単に `database`という名前の範囲内にカーソルを置くだけで、同じファイル内の他のすべての参照をすばやく見ることができます。右クリックして` Find All References`を選択すると、プロジェクトの使用法が表示されますワイド。

    <img src = "/images/2017_01_03_WordHighlight.png" width = "300px" />

5.ホバー上の変数型をすばやく調べる以外に、変数が別のファイルにある場合でも変数の定義を調べることができます。たとえば、12行目の `database.localUrl`を右クリックし、` Peek Definition`を選択すると、デフォルトでMongoDBに接続するようにアプリケーションがどのように設定されているかが素早く確認できます。

    <img src = "/images/2017_01_03_CodePeek.png" width = "550px" />

クラウドネイティブ、[12要素のアプリケーション](https://12factor.net/)はこのようなハードコード構成ではないので、MongoDB接続文字列を環境変数で設定する方が良いでしょう。展開/環境ごとに変更されました。その変更をしましょう！

##オートコンプリート

自動補完機能は、コードを書く/探索する際の生産性を大幅に向上させることができます。これにより、ドキュメントを参照したり、APIのタイプミスを心配する必要がなくなります。たとえば、ハードコードされたMongoDB接続文字列を環境変数で補足して、12行目を以下のように変更してみましょう：

`` `javascript
mongoose.connect(database.localUrl);
`` ``

これに：

`` `javascript
mongoose.connect(process.env.MONGO_URL || database.localUrl);
`` ``

`process.`とタイプすると、Node.jsの` process`グローバルAPIの利用可能なメンバーが VS Code で表示され、何も設定する必要はありませんでした。

<img src="/images/2017_01_03_ProcessEnv.png" width="350px" />

これは、 VS Code がタイプ情報を提供するためにシーンの背後にあるTypeScript(JavaScriptの場合でも)を使用するためです。タイプ情報を入力すると補完リストに通知できます。 VS CodeはこれがNode.jsプロジェクトであることを検出することができます。その結果、[Node.js](https://www.npmjs.com/package/@types/node)のTypeScript入力ファイルが自動的にダウンロードされ、 NPMから。これにより `Buffer`や` setTimeout`のような他のNode.jsグローバルや `fs`や` http`などの組み込みモジュールの補完が可能になります。

組み込みのNode.js APIに加えて、入力の自動取得は、React、Underscore、Expressなどの2,000以上のサードパーティライブラリでも機能します。たとえば、設定されたMongoDBデータベースインスタンスに接続できない場合、Mongooseがサンプルアプリケーションをクラッシュさせないようにするには、次のコード行を13行目に追加します。

`` `javascript
mongoose.connection.on( "error"、()=> {console.log( "DB接続エラー");});
`` ``

それを入力すると、何もする必要なく、もう一度完了することがわかります。

<img src = "/images/2017_01_03_Mongoose.png" width = "300px" />

このオートコンプリート機能をサポートするライブラリは、すべてのTypeScript型定義のコミュニティ主導の素晴らしい[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)プロジェクトを参照することで確認できます。

##アプリケーションを実行する

これで、このアプリを少し調べて調整したので、今すぐ実行する時間です。これを行うには、単に `F5`を押してアプリを実行してください。これまで実行しようとしたことは初めてですから、使用する「実行コンフィギュレーション」のタイプを指定するように求められます。

<img src = "/images/2017_01_03_DebugConfig.png" width = "450px" />

最近Node.jsに追加された新しいChromeデバッグプロトコルのサポートを使用する `Node.js v6.3 +(Experimental)`を選択してください。そうすることで、あなたのプロジェクトに `launch.json`という新しいファイルが生成されます。このファイルは、 VS Code でデバッグするためにアプリを起動および/または接続する方法を伝えるだけです。

<img src = "/images/2017_01_03_LaunchJson.png" width = "300px" />

アプリケーションの起動スクリプトが `server.js`であることを検出できたことに注目してください。もう一度、デバッグを動作させるために何も変更する必要はありません。

この時点でもう一度F5を押してアプリを起動します。これは、VS Codeの `Debug Console`ウィンドウとともにアプリケーションを起動します。これは、新しく実行されているアプリケーションのstdoutを表示します。

<img src = "/images/2017_01_03_Console.png" width = "450px" />

さらに、このコンソールは新しく実行されるアプリに実際に接続されているので、JavaScript式を入力することができます。これはアプリで評価され、自動補完も含まれます！たとえば、コンソールに `process.env`と入力すると、何を意味するのかを確認できます。

<img src = "/images/2017_01_03_ConsoleCode.png" width = "450px" />

ブラウザを開くと、 `http：//localhost：8080`にナビゲートして実行中のアプリケーションを見ることができます。テキストボックスにメッセージを入力し、いくつかのtodosを追加/削除して、アプリケーションの仕組みを感じてください。

<img src = "/images/2017_01_03_Todo.png" width = "350px" />

##デバッグ

 VS Code は、アプリケーションを実行し、統合されたコンソールを介してアプリケーションと対話できるだけでなく、コード内にブレークポイントを直接設定する機能も提供します。例えば、 `CTRL + P`を押してファイルピッカーを起動し、` route`とタイプして `route.js`ファイルを選択します。

28行目にブレークポイントを設定しましょう。これは、アプリがToDoを追加しようとするときに呼び出されるExpressルートを表します。ブレークポイントを設定するには、エディター内の行番号の左側にあるガターをクリックします。

<img src = "/images/2017_01_03_Breakpoint.png" width = "350px" />

*注：標準のブレークポイントに加えて、 VS Code は条件付きブレークポイントもサポートしています。これにより、アプリケーションが実行を中断するタイミングをカスタマイズできます。それらを使用するには、ガターを右クリックし、条件付きブレークポイントを追加...を選択し、ブレークポイントを条件付けするJavaScript式(例えば `foo =" bar "`)またはヒットカウントを指定するだけです。*

その設定で、実行中のアプリに戻り、ToDoを追加します。これはすぐにアプリケーションの実行を中断させ、 VS Code はブレークポイントを設定する28行目で一時停止します：

<img src = "/images/2017_01_03_Debugger.png" width = "350px" />

一時停止したファイル内で、式を上書きして現在の値を表示し、ローカル/時計と呼び出しスタックを検査し、上部のデバッグツールバーを使用して実行をステップ実行できます。あなたがIDEから期待するすべてのものが、軽量のテキストエディタで。アプリの実行を続けるには、もう一度F5を押してください。

##完全なスタックのデバッグ

前述のように、これはMEANアプリケーションです。つまり、フロントエンドとバックエンドの両方がJavaScriptを使用して書かれています。バックエンドのノード/エクスプレスコードをデバッグしている間に、フロントエンド/アングルコードをデバッグする必要が生じることがあります。幸運なことに、 VS Code には、統合されたChromeのデバッグなど、簡単にインストールできる拡張機能のエコシステムがあります。

これを実証するには、拡張機能タブに切り替えて、検索ボックスに「chrome」と入力します。

<img src = "/images/2017_01_03_Chrome.png" width = "350px" />

`Debugger for Chrome`という拡張子を選択し、` Install`ボタンをクリックしてください。その後、 VS Code をリロードして拡張機能を有効にする必要があります。それはあなたのワークスペースを再起動の間中存続させるので、状態を失う心配はありません。

`CTRL + P`と打ち、` launch.json`を入力/選択し、そのファイルの内容を次のように置き換えます：

`` `json
{
    "version"： "0.2.0"、
    "化合物"：[
        {
            "name"： "Full-Stack"、
            "設定"：["Node"、 "Chrome"]
        }
    ]、
    "構成"：[
        {
            "name"： "Chrome"、
            "type"： "chrome"、
            "request"： "launch"、
            "url"： "http：//localhost：8080"、
            "ポート"：9222、
            "userDataDir"： "$ {workspaceRoot} /。vscode/chrome"、
            "webRoot"： "$ {workspaceRoot}/public"
        }、
        {
            "name"： "Node"、
            "type"： "node2"、
            "request"： "launch"、
            "program"： "$ {workspaceRoot} /server.js"、
            "cwd"： "$ {workspaceRoot}"
        }
    ]
}
`` ``

この変更は2つのことを行います：

1. Chromeの新しい実行設定を追加します。これにより、フロントエンドのJavaScriptコードをデバッグできます。指定された設定の上にマウスを置くと、マウスの操作に関するドキュメントを表示できます。ニース！

2. "化合物"実行コンフィギュレーションを追加すると、フロントエンドとバックエンドのコードを同時にデバッグできます！後ほど説明するように、複合構成概念は本当に強力です！

この動作を確認するには、 VS Code のデバッグタブに切り替え、選択した設定を「フルスタック」に変更します(これは複合設定と呼ばれ、何でも名前を付けることができます)。次に `F5 `それを実行する。

<img src = "/images/2017_01_03_FullStackProfile.png" width = "250px" />

これにより、Node.jsアプリケーション(デバッグコンソールの出力に表示されるように)と、http：//localhost：8080のNode.jsアプリケーションに移動するように設定されているChromeが起動されます。

`CTRL + P`と打ち込んだり、/todos.jsを入力/選択してください。これはアプリのフロントエンドの主な角度コントローラーです。 11行目にブレークポイントを設定します。ブレークポイントは作成する新しいToDoのエントリポイントです。

実行中のアプリケーションに戻り、新しいToDoを追加すると、 VS Code がAngularコード内で実行を中断していることがわかります：

<img src = "/images/2017_01_03_ChromePause.png" width = "350px" />

Node.jsのデバッグと同様に、式の上にマウスを置いたり、ローカル/ウォッチを表示したり、コンソールで式を評価したりすることができます。ただし、今考慮すべき点は2つあります。

1. `Call Stack`ペインには` Node`と `Chrome`という2つの異なるスタックが表示され、どちらが現在一時停止しているのかを示します。

2.フロントエンドコードとバックエンドコードの間を行き来することができます！これをテストするには、単純に `F5`を押すと実行され、以前にExpressルートで設定したブレークポイントにヒットします。

この設定により、 VS Code 内で正面、背面、または完全スタックのJavaScriptコードを効率的にデバッグできるようになりました。さらに、複合デバッガのコンセプトは、2つのターゲットプロセスに限定されるものではなく、JavaScriptに限定されるものではありません。したがって、マイクロサービスアプリケーションで作業している場合は、多言語でも可能です。必要な拡張機能(例えば、Go、Ruby、PHPなど)をインストールしたら、上記と同じワークフローを実行します。

##あなたのアプリケーションをドッキングする

マイクロサービスについて言えば、 VS Code がDockerで開発するための経験を見てみましょう。多くのNode.js開発者は、Dockerを使用して、開発環境、CI環境、本番環境の両方で移植可能なアプリを提供しています。つまり、Dockerのメリットは非常に高いものの、学習曲線と開始コストがかなり高いというフィードバックが数多く寄せられています。  VS Code は、そのオンボーディングの一部を簡素化するのに役立つ拡張機能を提供します。

拡張機能タブに戻り、 `docker`を検索し、` Docker Support`拡張を選択してください。上記のChrome拡張機能と同じように、 VS Code をインストールしてからリロードしてください。

<img src = "/images/2017_01_03_DockerSearch.png" width = "350px" />

この拡張には多くのものが含まれています。そのうちの1つは、既存のプロジェクトの `Dockerfile`と` docker-compose.yml`ファイルを生成するための簡単なコマンドです。これを実際に見るには `F1`(コマンドパレットを表示する)と` docker`とタイプしてDocker拡張機能が提供するすべてのコマンドを表示してください：

<img src = "/images/2017_01_03_DockerCommands.png" width = "350px" />

`Docker：作業スペースにdockerファイルを追加する 'コマンドを選択し、アプリケーションプラットフォームとしてNode.jsを選択し、アプリケーションがポート8080を公開するように指定します。これにより、すぐに使用できる完全な `Dockerfile`とDockerの作成ファイルが生成されます。

<img src="/images/2017_01_03_Dockerfile.png" width="450px" />

Dockerエクステンションは `Dockerfiles`と` docker-compose.yml`ファイルの自動補完も提供します。これによりDockerアセットをより簡単にオーサリングすることができます。例えば、 `Dockerfile`を開き、2行目を以下から変更してください：

``ドッカー
FROMノード：最新
`` ``

に：

``ドッカー
FROM mhart
`` ``

`mhart`の` t`の後にカーソルを置いて `CTRL + Space`を押すと、` mhart`がDockerHubに公開したすべての画像リポジトリを表示します。

<img src = "/images/2017_01_03_DockerCompletion.png" width = "350px" />

非常に効率的で小さなLinuxディストリビューションであり、このアプリケーションが必要とするすべてのものを提供する `mhart/alpine-node`を選択してください。追加の膨らみはありません(Alpine LinuxはDockerに最適です！アプリケーションのビルドとデプロイメントをできるだけ速くしたいので、画像のサイズが小さいほうが一般的に優れています。分散/スケーリングなどがあります。クイック。

`Dockerfile`があるので、実際のDockerイメージを構築する必要があります。もう一度、 `F1`をタイプして` dockerb`( "ファジー検索"を使用して)を入力することによって、Docker拡張がインストールしたコマンドを使用することができます。 `Docker：Build Image`コマンドを選択し、生成/編集したばかりの`/Dockerfile`を選択してから、あなたのDockerHubユーザ名を含むタグを画像に与えます(例えば、 `lostintangent/node`)。 `<ENTER>`を押すと統合されたターミナルウィンドウが起動し、ビルド中のDockerイメージの出力が表示されます。

<img src = "/images/2017_01_03_DockerBuild.png" width = "350xp" />

このコマンドは単にあなたのために `docker build`を実行するプロセスを自動化しました。これはあなたが使用することができる生産性エンハンサーの別の例でも、単にDocker CLIを直接使用することもできます。あなたのために何が一番うまくいくのですか？

この時点で、このイメージを展開用に簡単に取得できるようにするには、DockerHubにプッシュするだけです。これを行うには、コマンドパレットを開き、 `dockerpush`と入力して` Docker：Push`コマンドを選択します。ビルドしたばかりのイメージタグ(例えば `lostintangent/node`)を選択し、` <ENTER> `を押します。これは、 `docker push`を呼び出すことを自動化し、出力を統合端末に表示します。

##アプリケーションのデプロイ

DockerHubにアプリをDockerizedしてプッシュしたので、実際にクラウドにデプロイする必要があります。このためにAzureのPaaS製品であるAzure App Serviceを使用し、最近Node.js開発者に関連する2つの新しい機能を追加しました。

1.ネイティブのノードモジュールを使用して構築されたアプリケーション、またはWindowsをサポートしていない可能性のあるツールや、動作が異なる可能性のあるツールの非互換性を低減する、LinuxベースのVMのサポート。

2. Dockerイメージの名前を指定するだけで、App Serviceがイメージを自動的にプル、展開、および拡大できるようにするDockerベースの展開をサポートします。

開始するには、端末を開き、新しいAzure CLI 2.0を使用してAzureアカウントを管理し、ToDoアプリを実行するために必要なインフラストラクチャをプロビジョニングします。 `az login`コマンド(pre-reqsで述べたように）を使ってCLIからあなたのアカウントにログインしたら、App Serviceインスタンスをプロビジョニングしてtodoアプリコンテナを展開するために以下の手順を実行します：

1.リソースグループを作成します。リソースグループは、Azureリソースを整理するのに役立つ「名前空間」または「ディレクトリ」と考えることができます。 `-n`フラグはグループの名前であり、あなたが望むものとして指定することができます。

    `` bash
    azグループ作成-n nina-demo -l westus
    `` ``

    *注意： `-l`フラグはリソースグループの場所を示します。プレビュー中、Linux上のApp Serviceサポートは選択された地域でしか利用できないため、Western USに所在しておらず、他のどの地域が利用可能であるかを確認したい場合は、 `az appservice list-locations- linux-workers-enabled`をCLIから使用して、データセンターのオプションを表示します。

2. Appサービスプランを作成します。これにより、アプリケーションが展開されている基盤となるVMの作成とスケーリングが管理されます。もう一度、nameフラグに使用する値を指定します。ただし、 `-g`フラグが上記のリソースグループに指定した名前を参照していることを確認してください。

    `` bash
    az appserviceプラン作成-n nina-demo-plan -g nina-demo --is-linux
    `` ``
    
    *注意： `--is-linux`フラグはキーです。これはLinuxベースのVMが必要なことを示しているからです。それがなければ、CLIはWindowsベースのVMをプロビジョニングします。

3.作成した計画とリソースグループ内で実行される予定アプリを表すApp Service Webアプリを作成します。おおまかに言えば、Webアプリケーションはプロセスやコンテナと同義であり、計画は実行中のVM /コンテナホストであると考えることができます。

    `` bash
    az appservice web作成-n nina-demo-app -p nina-demo-plan -g nina-demo
    `` ``

4. Dockerイメージを使用するようにWebアプリケーションを設定し、 `-c`フラグにDockerHubアカウント/イメージ名の名前を設定します。

    `` bash
    az appservice web configコンテナのアップデート-n nina-demo-app -g nina-demo -c lostintangent/node
    `` ``

5.デプロイされたばかりのコンテナを表示するためにアプリケーションを起動します。これは `* .azurewebsites.net`のURLで利用できます：

    `` bash
    az appservice web browse -n nina-demo-app -g nina-demo
    `` ``

    <img src = "/images/2017_01_03_BrowseApp.png" width = "300px" />

    *注：App ServiceはDockerHubからDockerイメージをプルして起動する必要があるため、アプリを最初に読み込むには1分ほどかかることがあります。

わーい！アプリをデプロイしました。しかし、回転アイコンは、アプリケーションがデータベースに接続できないことを示しています。これは開発中にMongoDBのローカルインスタンスを使用していたため意味があります。Azureデータセンタからは届きません。幸いにも、環境変数を介して接続文字列を受け入れるようにアプリケーションを更新したので、MongoDBサーバーを起動し、App Serviceインスタンスを再構成して参照するだけで済みます。

## DocumentDBの使用

Azureは、MongoDBサーバーまたはレプリカセットをセットアップし、そのインフラストラクチャを管理することができますが、DocumentDBという別のソリューションを提供しています。 DocumentDBは完全に管理された、地理的に複製可能な、高性能なNoSQLデータベースで、MongoDB互換レイヤーを提供します。これは、接続文字列以外のものを変更することなく、既存のMEANアプリケーションを指すことができることを意味します。今度はAzureポータルを使用してCLIを使用する方法を見てみましょう。

1. portal.azure.comにアクセスし、CLIで使用していたのと同じアカウントにログインします。

<img src = "/images/2017_01_03_AzurePortal.png" width = "350px" />

2.「N」キーを押して新しいAzureリソースを作成し、「Databases」を選択してから「NoSQL(DocumentDB)」を選択します。

<img src = "/images/2017_01_03_CreateDocDB.png" width = "300px" />

3.インスタンスに任意の名前を付けますが、 `MongoDB`と`リソースグループ 'を `Use Existing`に使い、App Serviceインスタンス用に作成したのと同じリソースグループを選択するよう` NoSQL API`を設定します。

<img src = "/images/2017_01_03_DocDBCreate.png" width = "250px" />

4.「作成」ボタンをクリックし、DBがプロビジョニングされるまで待ちます。
    
DocumentDBインスタンスを完全に作成するには、しばらく時間がかかるため、ポータルの右上に配置の成功通知が表示されるまで待ちます。完了したら、左側のナビゲーションバーの `All Resources`タブ(緑色のグリッドアイコンを持つメニュー項目)にナビゲートし、作成したDocumentDBリソースを選択します：

<img src = "/images/2017_01_03_AllResources.png" width = "350px" />

MongoDB接続文字列をクリップボードにコピーするには、 `Settings`セクションの下にある` Connection String`メニュー項目をクリックし、 `Connection String`フィールドの隣にある` copy 'ボタンをクリックします。

<img src = "/images/2017_01_03_ConnectionString.png" width = "450px" />

ポータル内の `All Resources`ページに戻り、以前作成した` App Service`インスタンスに移動します。 `Settings`セクションの下にある` Application Settings`メニュー項目をクリックし、キーが `MONGO_URL`で、以前にコピーしたDocumentDB接続文字列が` App settings`セクションの下に新しいエントリを追加します。

<img src = "/images/2017_01_03_AppSettings.png" width = "450px" />

`Save`ボタンを押して、ブラウザに戻り、それをリフレッシュしてください。 Todoアイテムを追加して削除してみて、何も変更することなくアプリが動作することを証明してください！作成したDocumentDBインスタンスに環境変数を設定するだけで、MongoDBデータベースを完全にエミュレートします。

<img src = "/images/2017_01_03_FinishedDemo.png" width = "450px" />

必要に応じて、DocumentDBインスタンスに戻り、MongoDBインスタンスが必要とする予約されたスループットをスケールアップ(または縮小)して、インフラストラクチャを手動で管理する必要なしに追加されたトラフィックから利益を得ることができます。

<img src = "/images/2017_01_03_DocDBScale.png" width = "350px" />

さらに、DocumentDBは自動的にすべてのドキュメントとプロパティのインデックスを作成しますので、クエリのプロファイリングやインデックスの手動調整を心配する必要はありません。必要に応じてプロビジョニングとスケーリングを行い、残りの部分をDocumentDBで処理させてください！

＃＃ 掃除

あなたが使用していないAzureリソースに課金されないようにするには、端末から次のコマンドを実行して、単にプロビジョニングしたすべてのリソースを削除してください：

`` bash
azグループの削除-n nina-demo
`` ``

##結論

うまくいけば、このデモでは、Visual Studio CodeがNode.jsの開発経験を向上させるためのいくつかの方法を説明してくれることを願っています。 フルスタックとマイクロサービスをサポートするデバッグと、他の設定なしでナビゲーションと自動補完を提供する豊富なオーサリング体験、Dockerなどの拡張機能のエコシステムがあり、他のアプリの種類や習慣のフィードバックループを強化することができます。 軽量エディタの中から生産性を見えるように進化させることに興奮しています。

さらに、Azure CLI、App Service、DocumentDBの間では、インフラストラクチャの複雑さを増やすことなく、必要に応じて拡張できるNode.js/MEANアプリケーション用の生産性の低い管理クラウドスタックを提供しようとしています。

NINA 2016デモのウォークスルーだけでなく、このデモを使用してVS CodeとAzureのNode.js体験を繰り返して、よりシンプルで柔軟性のあるものにしていきたいと考えています。 改善のためのご質問やご意見がございましたら、お気軽にこのレポに関する問題を提出するか、[電子メール](mailto：joncart@microsoft.com)までお送りください。 ありがとう！
